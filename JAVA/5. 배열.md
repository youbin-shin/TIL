# 5. 배열

## 메모리 구조

- 모든 자바 프로그램은 자바 가상 머신(JVM)을 통해서 실행된다.

- 자바 프로그램이 실행되면, JVM은 운영 체제로부터 해당 프로그램을 수행할 수 있도록 필요한 메모리를 할당받는다.

  - JVM은 용도에 따라 구분되어 관리한다.

    |                         |               메모리                |             |
    | ----------------------- | :---------------------------------: | ----------- |
    | 낮은 주소 (low memory)  |       클래스<br />클래스 변수       | 메소드 영역 |
    |                         |         객체<br />인스턴스          | 힙 영역 ↓   |
    | 높은 주소 (high memory) | 메소드<br />지역 변수<br />매개변수 | 스택 영역 ↑ |

### 메소드(method) 영역

- 자바 프로그램에서 사용되는 클래스에 대한 정보와 함께 클래스 변수(static variable)가 저장되는 영역이다.
- JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일(*.class)를 읽고 해당 클래스에 대한 정보를 메소드 영역에 저장한다.

### 힙(heap) 영역

- 자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역이다.
- JVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면 해당 인스턴스의 정보를 힙 영역에 저장한다.
- 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

### 스택(stack) 영역

- 자바 프로그램에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역이다.
- JVM은 자바 프로그램에서 메소드가 호출되면, 메소드의 호출과 관계되는 지역 변수와 매개변수를 스택 영역에 저장한다.
  - 스택 영역은 메소드의 호출과 함께 할당괴고 메소드의 호출이 완료되면 소멸된다.
  - 스택 영역에 저장되는 메소드의 호출 정보를 스택 프레인(stack frame)이라 한다.
- 스택 영역은 push 동작으로 데이터를 저장하고 pop 동작으로 데이터를 인출한다.
  - 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출된다.
- 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.



## 1차원 배열

### 배열 (array)이란?

- 배열은 같은 타입의 변수들로 이루어진 유한 집합으로 정의 가능하다.
  - 배열 요소 (element): 배열을 구성하는 각각의 값
  - 인덱스 (index): 배열에서의 위치를 가리키는 숫자
    - java에서 인덱스는 언제나 0부터 시작하며, 0을 포함한 양의 정수만을 가질 수 있다.
- 배열은 같은 종류의 데이터를 많이 다뤄야 하는 경우에 사용할 수 있는 가장 기본적인 자료 구조이다.
- 배열은 선언되는 형식에 따라 1차원 배열, 2차원 배열, 그 이상의 다차원 배열로도 선언 가능하다.

### 1차원 배열

```java
// 문법 구조

// 선언
// 1.
타입[] 배열이름;
// 2.
타입 배열이름[];

// 배열 생성
배열 이름 = new 타입[배열 길이];

// 선언 + 생성 "동시에"
타입[] 배열이름 = new 타입[배열 길이];
```

- 타입 : 배열 요소로 저장되는 변수의 타입
- 배열 이름 : 배열이 선언된 후에 배열에 접근하기 위해 사용됨.

```java
// 예제
int[] grade1 = new int[3]; // 길이가 3인 int형 배열의 선언 및 생성
int[] grade2 = new int[3]; // 길이가 3인 int형 배열의 선언 및 생성

grade1[0] = 85; // 인덱스를 이용한 배열의 초기화
grade1[1] = 65;
grade1[2] = 90;
 
grade2[0] = 85; // 배열의 길이보다 적은 수의 배열 요소만 초기화

for (int i = 0; i < grade1.length; i++) {
    System.out.print(grade1[i] + " "); // 인덱스를 이용한 배열로의 접근
} 

for (int i = 0; i < grade2.length; i++) {
    System.out.print(grade2[i] + " "); // 인덱스를 이용한 배열로의 접근
}
```

```markdown
출력 결과
85 65 90 
85 0 0 
```

- 배열에 인덱스 범위를 벗어난 인덱스를 출력하면 `ArrayIndexOutOfBounds` 예외가 발생한다.

### 배열의 초기화

1. 배열의 선언과 초기화를 따로 진행해야 할 경우
2. 메소드의 인수로 배열을 전달하면서 초기화해야 할 경우

```java
// 문법 구조
// 1. 
타입[] 배열이름 = {배열요소1, 배열요소2, ...};

// 2. 
타입[] 배열이름 = new 타입[]{배열요소1, 배열요소2, ...};
```

- 초기화 블록에 맞게 자동으로 배열의 길이를 설정한다.

```java
// 예제
int[] grade1 = {70, 90, 80}; // 배열의 선언과 동시에 초기화할 수 있음.
int[] grade2 = new int[]{70, 90, 80}; // 배열의 선언과 동시에 초기화할 수 있음.
int[] grade3;
// grade3 = {70, 90, 80}; 이미 선언된 배열을 이 방법으로 초기화하면 오류가 발생함.
int[] grade4;
grade4 = new int[]{70, 90, 80}; // 이미 선언된 배열은 이 방법으로만 초기화할 수 있음.


// 선언과 동시에 초기화하는 예제
int[] grade = new int[]{85, 65, 90};  // 길이가 3인 int형 배열을 선언과 동시에 초기화
for (int i = 0; i < grade.length; i++) {
    System.out.print(grade[i] + " "); // 인덱스를 이용한 배열로의 접근
}
// 배열의 요소의 합, 평균을 구하는 예제
int sum = 0;
for (int i = 0; i < grade.length; i++) {
    sum += grade[i];
}
System.out.println("모든 과목에서 받은 점수의 합은 " + sum + "입니다.");
System.out.println("이 학생의 평균은 " + (sum / grade.length) + "입니다.");
```

```markdown
출력 결과
85 65 90
모든 과목에서 받은 점수의 합은 240입니다.
이 학생의 평균은 80입니다.
```



## 다차원 배열 (multi-dimensional array)

- 2차원 이상의 배열을 의미하며, 배열 요소로 또 다른 배열을 가지는 배열을 의미한다.
  - 2차원 배열 : 배열 요소로 1차원 배열을 가지는 배열
    - 2차원 배열을 나타내는 타입을 따로 제공하지 X
    - 1차원 배열의 배열 요소로 또 다른 1차원 배열을 사용하여 표현 가능
  - 3차원 배열 : 배열 요소로 2차원 배열을 가지는 배열

### 2차원 배열

```java
// 문법 
// 1. 
타입[][] 배열이름;

// 2.
타입 배열이름[][];

// 3.
타입[] 배열이름[];
```

```java
// 예제

int[][] arr = new int[2][3];
int k = 10;

for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        arr[i][j] = k; // 인덱스를 이용한 초기화
        k += 10;
    }
}

for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        System.out.print(arr[i][j] + " ");
    }
    System.out.println();
}

// 출력
// 10 20 30 
// 40 50 60 
```

### 배열 선언 + 초기화

```java
// 문법
타입 배열이름[열의길이][행의길이] = {
    {배열요소[0][0], 배열요소[0][1], ...},
    {배열요소[1][0], 배열요소[1][1], ...},
    ...
};
```

```java
// 예제
int[][] arr = {
    {10, 20, 30},
    {40, 50, 60}
};
```

### 가변 배열 (dynamic array)

- 2차원 배열을 생성할 때 열의 길이를 명시하지 않음으로써, 행마다 다른 길이의 배열을 요소로 저장 가능하다.
- 행마다 다른 길이의 배열을 저장할 수 있는 배열을 가변 배열이라 한다.

```java
// 예제 : 선언
int[][] arr = new int[3][];
arr[0] = new int[2];
arr[1] = new int[4];
arr[2] = new int[1];

// 예제 : 선언 + 초기화
int[][] arr = {
    {10, 20},
    {10, 20, 30, 40},
    {10}
};
```



## 배열의 활용

- java에서는 배열을 한 번 생성하면 그 길이를 변경할 수 없다.

- 더 많은 데이터를 저장하기 위해서는 더욱 큰 배열을 만들고, 이전 배열의 데이터를 새로 만든 배열로 복사해야 한다.

  - 복사하는 방법

    1.  System 클래스의 arraycopy() 메소드

       가장 좋은 성능을 보임.

    2. Arrays 클래스의 copyOf() 메소드

       가장 많이 사용되는 메소드

    3. Object 클래스의 clone() 메소드

    4. for 문과 인덱스를 이용한 복사

```java
// 예제
int[] arr1 = new int[]{1, 2, 3, 4, 5};
int newLen = 10;

// 1. System 클래스의 arraycopy() 메소드
int[] arr2 = new int[newLen];
System.arraycopy(arr1, 0, arr2, 0, arr1.length);

// 2. Arrays 클래스의 copyOf() 메소드
int[] arr3 = Arrays.copyOf(arr1, 10);

// 3. Object 클래스의 clone() 메소드
int[] arr4 = (int[])arr1.clone();

// 4. for 문과 인덱스를 이용한 복사
int[] arr5 = new int[newLen];
```

```markdown
출력
1 2 3 4 5 0 0 0 0 0 
1 2 3 4 5 0 0 0 0 0 
1 2 3 4 5 
1 2 3 4 5 0 0 0 0 0
```

### Enhanced for 문

- 배열과 컬렉션의 모든 요소를 참조하기 위한 Enhanced for 문은 배열과 컬렉션 프레임워크에서 유용하게 사용한다.

```java
// 문법
for (타입 변수이름 : 배열이나컬렉션이름) {
    배열의 길이만큼 반복적으로 실행하고자 하는 명령문;
}
```

- 명시한 배열이나 컬렉션의 길이만큼 반복되어 실행된다.
- 루프마다 각 요소는 명시한 변수의 이름으로 저장되며,  명령문에서는 이 변수를 사용하여 각 요소를 참조 가능하다.

```java
// 각 배열 요소의 값을 출력하는 예제
int[] arr = new int[]{1, 2, 3, 4, 5};

for (int e : arr) {
    System.out.print(e + " ");
}

// 출력 : 1 2 3 4 5
```

- Enhanced for 문은 요소를 참조할 때만 사용하는 것이 좋고 요소의 값을 변경하는 작업에는 적합하지 않다.

```java
// 모든 배열 요소에 10을 더하는 예제
int[] arr1 = new int[]{1, 2, 3, 4, 5};
int[] arr2 = new int[]{1, 2, 3, 4, 5};

// for 문 이용
for (int i = 0; i < arr1.length; i++) {
    arr1[i] += 10;
}

// Enhanced for 문 이용
for (int e : arr2) {
    e += 10;
}
```

```markdown
출력
11 12 13 14 15
1 2 3 4 5
```

- for 문을 통해서 각 배열 요소의 값을 변경가능하다.
- Enhanced for 문을 이용하면 원본 배열에는 아무런 변화가 없다.
  - Enhanced for 문 내부에서 사용되는 배열 요소는 배열 요소의 복사본이다.
  - 원본 배열에는 아무런 영향을 주지 못한다.