# 5. 배열

## 메모리 구조

- 모든 자바 프로그램은 자바 가상 머신(JVM)을 통해서 실행된다.

- 자바 프로그램이 실행되면, JVM은 운영 체제로부터 해당 프로그램을 수행할 수 있도록 필요한 메모리를 할당받는다.

  - JVM은 용도에 따라 구분되어 관리한다.

    |                         |               메모리                |             |
    | ----------------------- | :---------------------------------: | ----------- |
    | 낮은 주소 (low memory)  |       클래스<br />클래스 변수       | 메소드 영역 |
    |                         |         객체<br />인스턴스          | 힙 영역 ↓   |
    | 높은 주소 (high memory) | 메소드<br />지역 변수<br />매개변수 | 스택 영역 ↑ |

### 메소드(method) 영역

- 자바 프로그램에서 사용되는 클래스에 대한 정보와 함께 클래스 변수(static variable)가 저장되는 영역이다.
- JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일(*.class)를 읽고 해당 클래스에 대한 정보를 메소드 영역에 저장한다.

### 힙(heap) 영역

- 자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역이다.
- JVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면 해당 인스턴스의 정보를 힙 영역에 저장한다.
- 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

### 스택(stack) 영역

- 자바 프로그램에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역이다.
- JVM은 자바 프로그램에서 메소드가 호출되면, 메소드의 호출과 관계되는 지역 변수와 매개변수를 스택 영역에 저장한다.
  - 스택 영역은 메소드의 호출과 함께 할당괴고 메소드의 호출이 완료되면 소멸된다.
  - 스택 영역에 저장되는 메소드의 호출 정보를 스택 프레인(stack frame)이라 한다.
- 스택 영역은 push 동작으로 데이터를 저장하고 pop 동작으로 데이터를 인출한다.
  - 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출된다.
- 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.



## 1차원 배열

### 배열 (array)이란?

- 배열은 같은 타입의 변수들로 이루어진 유한 집합으로 정의 가능하다.
  - 배열 요소 (element): 배열을 구성하는 각각의 값
  - 인덱스 (index): 배열에서의 위치를 가리키는 숫자
    - java에서 인덱스는 언제나 0부터 시작하며, 0을 포함한 양의 정수만을 가질 수 있다.
- 배열은 같은 종류의 데이터를 많이 다뤄야 하는 경우에 사용할 수 있는 가장 기본적인 자료 구조이다.
- 배열은 선언되는 형식에 따라 1차원 배열, 2차원 배열, 그 이상의 다차원 배열로도 선언 가능하다.

### 1차원 배열

```java
// 문법 구조

// 선언
// 1.
타입[] 배열이름;
// 2.
타입 배열이름[];

// 배열 생성
배열 이름 = new 타입[배열 길이];

// 선언 + 생성 "동시에"
타입[] 배열이름 = new 타입[배열 길이];
```

- 타입 : 배열 요소로 저장되는 변수의 타입
- 배열 이름 : 배열이 선언된 후에 배열에 접근하기 위해 사용됨.

```java
// 예제
int[] grade1 = new int[3]; // 길이가 3인 int형 배열의 선언 및 생성
int[] grade2 = new int[3]; // 길이가 3인 int형 배열의 선언 및 생성

grade1[0] = 85; // 인덱스를 이용한 배열의 초기화
grade1[1] = 65;
grade1[2] = 90;
 
grade2[0] = 85; // 배열의 길이보다 적은 수의 배열 요소만 초기화

for (int i = 0; i < grade1.length; i++) {
    System.out.print(grade1[i] + " "); // 인덱스를 이용한 배열로의 접근
} 

for (int i = 0; i < grade2.length; i++) {
    System.out.print(grade2[i] + " "); // 인덱스를 이용한 배열로의 접근
}
```

```markdown
출력 결과
85 65 90 
85 0 0 
```

- 배열에 인덱스 범위를 벗어난 인덱스를 출력하면 `ArrayIndexOutOfBounds` 예외가 발생한다.

### 배열의 초기화

1. 배열의 선언과 초기화를 따로 진행해야 할 경우
2. 메소드의 인수로 배열을 전달하면서 초기화해야 할 경우

```java
// 문법 구조
// 1. 
타입[] 배열이름 = {배열요소1, 배열요소2, ...};

// 2. 
타입[] 배열이름 = new 타입[]{배열요소1, 배열요소2, ...};
```

- 초기화 블록에 맞게 자동으로 배열의 길이를 설정한다.

```java
// 예제
int[] grade1 = {70, 90, 80}; // 배열의 선언과 동시에 초기화할 수 있음.
int[] grade2 = new int[]{70, 90, 80}; // 배열의 선언과 동시에 초기화할 수 있음.
int[] grade3;
// grade3 = {70, 90, 80}; 이미 선언된 배열을 이 방법으로 초기화하면 오류가 발생함.
int[] grade4;
grade4 = new int[]{70, 90, 80}; // 이미 선언된 배열은 이 방법으로만 초기화할 수 있음.


// 선언과 동시에 초기화하는 예제
int[] grade = new int[]{85, 65, 90};  // 길이가 3인 int형 배열을 선언과 동시에 초기화
for (int i = 0; i < grade.length; i++) {
    System.out.print(grade[i] + " "); // 인덱스를 이용한 배열로의 접근
}
// 배열의 요소의 합, 평균을 구하는 예제
int sum = 0;
for (int i = 0; i < grade.length; i++) {
    sum += grade[i];
}
System.out.println("모든 과목에서 받은 점수의 합은 " + sum + "입니다.");
System.out.println("이 학생의 평균은 " + (sum / grade.length) + "입니다.");
```

```markdown
출력 결과
85 65 90
모든 과목에서 받은 점수의 합은 240입니다.
이 학생의 평균은 80입니다.
```

