# 7. 메소드와 생성자

## 메소드 (method)

- 어떠한 특정 작업을 수행하기 위한 명령문의 집합

- java에서 클래스는 멤버로 속성을 표현하는 필드와 기능을 표현하는 메소드를 가진다.

- 사용 목적 ?

  중복되는 코드 피할 수 O

  모듈화로 인해 코드의 가독성 ↑

  프로그램에 문제가 발생하거나 기능 변경이 필요할 때 유지보수 용이

- 메소드를 작성할 때는 되도록 하나의 메소드가 하나의 기능만을 수행하도록 작성한다.

### 메소드 정의

```java
// 문법 
접근제어자 반환타입 메소드이름(매개변수 목록) { // 선언부
    // 구현부
}
```

- 접근 제어자 : 해당 메소드에 접근할 수 있는 범위 명시
- 반환 타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입 명시
- 메소드 이름 : 메소드를 호출하기 위한 이름 명시
- 매개변수 목록 (parameters) : 메소드 호출 시 전달되는 인수의 값을 저장할 변수들을 명시
- 구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합



```java
// 예제 1
class Car {
    private int currentSpeed;
    private int accelerationTime;
    
    public void accelerate(int speed, int second) { // 선언부
        // 구현부
        System.out.println(second + "초간 속도를 시속 " + speed + "(으)로 가속함.");
    }
}
```

- accelerate() 메소드 정의
  - public 접근 제어자를 사용하여 선언되어 해당 객체를 사용하는 프로그램 어디서나 직접 접근 가능
  - 반환 타입에는 어떠한 값도 반환하지 않음을 의미하는 void를 명시
  - 매개변수 int형 변수인 speed와 second를 전달받음
    - 전달받은 매개변수를 통해 메소드 구현부에서 고유한 작업을 수행할 수 있음

### 메소드 호출

`.` 멤버 참조 연산자를 사용하여 호출할 수 있다.

```java
// 문법
// 1. 매개변수가 없는 메소드의 호출시
객체참조변수이름.메소드이름();

// 2. 매개변수가 있는 메소드의 호출시
객체참조변수이름.메소드이름(인수1, 인수2, ...);
```



```java
// 예제 2 : 예제 1에서 정의한  accelerate() 메소드 호출

Car myCar = new Car(); // 객체 생성
myCar.accelerate(60, 3); // myCar 인스턴스의 accelerate() 메소드를 호출

// 출력 : 3초간 속도를 시속 60(으)로 가속함.
```

```java
// 예제 3 : accelerate() 메소드 정의 & 호출

class Car {
    private int currentSpeed;
    private int accelerationTime;
    
    public void accelerate(int speed, int second) { // 선언부
        // 구현부
        System.out.println(second + "초간 속도를 시속 " + speed + "(으)로 가속함.");
    }
}

public class Method {
    public static void main(String[] args) {
        Car myCar = new Car(); // 객체 생성
        myCar.accelerate(60, 3); // 메소드 호출
    }
}

// 출력 : 3초간 속도를 시속 60(으)로 가속함.
```



## 생성자

### 인스턴스 변수의 초기화

- 클래스를 가지고 개겔 생성하면 해당 객체는 메모리에 즉시 생성된다.

  - 이 생성된 객체는 인스턴스 변수가 아직 초기화되지 않은 상태이다.

- 클래스 변수와 인스턴스 변수는 별도로 초기화하지 않으면 다음 값으로 자동 초기화된다.

  |     변수의 타입     |    초깃값     |
  | :-----------------: | :-----------: |
  |        char         |   '/u0000'    |
  |  byte, short, int   |       0       |
  |        long         |      0L       |
  |        float        |     0.0F      |
  |       double        | 0.0 또는 0.0D |
  |       boolean       |     false     |
  | 배열, 인스턴스, ... |     null      |

- 사용자가 원한느 값으로 인스턴스 변수를 초기화하려면?

  - 일반적인 초기화 방식으로는 초기화 불가능!
    - 인스턴스 변수 중에는 private 변수도 있고 이런 private 변수에는 사용자나 프로그램이 직접 접근 불가능하기 때문이다.
  - private 인스턴스 변수에도 접근할 수 있는 초기화만을 위한 public 메소드가 필요하다.
    - 이런 초기화만을 위한 메소드는 객체가 생성된 후부터 사용되기 전까지 반드시 인스턴스 변수의 초기화를 위해 호출되야 한다.

### 생성자 (constructor)

- 객체의 생성과 인스턴스 변수를 원하는 값으로 초기화수 있는 생성자라는 메소드를 제공한다.
  - 생성자의 이름은 해당 클래스의 이름과 같아야 한다.

#### 생성자의 특징

1. 생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않는다.
2. 생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있다.
3. 객체를 초기화하는 방법이 여러개 존재할 경우 하나의 클래스가 여러 개의 생성자를 가질 수 있다.
   - 생성자도 하나의 메소드! 즉 메소드 오버로딩이 가능하다.

```java
// 예제 1: Car 클래스 선언, 여러 개의 생성자 선언

Car(String modelName) {}
Car(String modelName, int modelYear) {}
Car(String modelName, int modelYear, String color) {}
Car(String modelName, int modelYear, String color, int maxSpeed) {}
```

#### 생성자의 선언

```java
// 문법
// 1. 매개변수가 없는 생성자 선언
클래스이름() {...}

// 2. 매개변수가 있는 생성자 선언
클래스이름(인수1, 인수2, ...) {...}
```

- 매개변수를 전달받아 인스턴스 변수를 초기화하는 생성자도 선언가능하다.

```java
// 예제 2 : Car 클래스의 생성자 선언

Car(String modelName, int modelYear, String color, int maxSpeeds) {
    this.modelName = modelName;
    this.modelYear = modelYear;
    this.color = color;
    this.maxSpeed = maxSpeed;
    this.currentSpeed = 0;
}
```

#### 생성자 호출

- `new` 키워드를 사용하여 객생성할 때 자동으로 생성자가 호출된다.

```java
class Car {
    private String modelName;
    private int modelYear;
    private String color;
    private int maxSpeed;
    private int currentSpeed;
    
    Car(String modelName, int modelYear, String color, int maxSpeed) {
        this.modelName = modelName;
        this.modelYear = modelYear;
        this.color = color;
        this.maxSpeed = maxSpeed;
        this.currentSpeed = 0;
    }

    public String getModel() {
        return this.modelYear + "년식 " + this.modelName + " " + this.color;
    }
}

public class Method02 {
    public static void main(String[] args) {
        Car myCar = new Car("velostar", 2020, "gray", 200); // 생성자의 호출
        System.out.println(myCar.getModel()); // 생성자에 의해 초기화되었는지를 확인함.
    }
}

// 출력 : 2020년식 velostar gray
```

### 기본 생성자 (default constructor)

- 모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 한다.

  - 생성자를 정의하지 않고도 인스턴스를 생성할 수 있다.

    => 자바 컴파일러가 기본 생성자(default constructor)을 기본적으로 제공해 주기 때문이다.

- 기본 생성자는 매개변수를 하나도 가지지 않고 명령어도 포함하고 있지 않다.



- 자바 컴파일러는 컴파일 시 클래스에 생성자가 정의되어 있지 않으면 자동으로 다음 같은 기본 생성자를 추가한다.

  ```java
  // 문법
  클래스이름() {}
  ```

  - 기본 생성자는 어떠한 매개변수도 전달받지 않으며 아무 동작도 하지 않는다.	

```java
// 예제 3 : Car 클래스에 생성자를 정의하지 않고, 기본 생성자 호출

class Car {
    private String modelName = "happycar";
    private int modelYear = 2020;
    private String color = "파란색";

    public String getModel() {
        return this.modelYear + "년식 " + this.color + " " + this.modelName;
    }
}

public class Method03 {
    public static void main(String[] args) {
        Car myCar = new Car(); // 기본 생성자의 호출
        System.out.println(myCar.getModel()); // 2020년식 파란색 happycar
    }
}
```

- Car 클래스의 인스턴스인 myCar는 기본 생성자를 사용하여 생성된다.
  - 기본 생성자는 아무런 동작도 하지 않으므로, 인스턴스 변수를 클래스 필드에서 바로 초기화한다.
  - 인스턴스 변수의 초기화는 생성자를 사용하여 수행가능하지만, 클래스 필드에서 바로 수행가능하다.
- 만약 매개변수를 가지는 생성자를 하나 이상 정의했다면, 기본 생성자는 자동으로 추가되지 않는다.
  - 매개변수를 가지는 생성자 하나 이상 정의한 후 기본 생성자를 호출하면 오류가 발생한다.

```java
// 예제 4 : 예제 3 + 매개변수를 갖는 생성자

class Car {
    private String modelName;
    private int modelYear;
    private String color;
    private int maxSpeed;
    private int currentSpeed;
    
    Car(String modelName, int modelYear, String color, int maxSpeed) {
        // 4개의 매개변수를 갖는 생성자 정의 => 자바 컴파일러는 Car 클래스에 별도의 기본 생성자를 추가하지 않는다.
        this.modelName = modelName;
        this.modelYear = modelYear;
        this.color = color;
        this.maxSpeed = maxSpeed;
        this.currentSpeed = 0;
    }
 
    public String getModel() {
        return this.modelYear + "년식 " + this.modelName + " " + this.color;
    }
}

public class Method04 {
    public static void main(String[] args) {
        Car myCar = new Car(); // 기본 생성자의 호출하여 인스턴스 생성하고자 한다. => 자바 컴파일러는 오류 발생!
        // 다음과 같이 4개의 매개변수를 전달해야 인스턴스가 생성된다. (생성자 호출)
        // Car myCar = new Car("happycar", 2020, "파란색", 200);
        System.out.println(myCar.getModel()); // 생성자에 의해 초기화되었는지를 확인함.
    }
}
```



## `this` vs `this()`

### this 참조 변수

- 인스턴스가 바로 자기 자신을 참조하는 데 사용하는 변수
- this 참조 변수는 해당 인스턴스의 주소를 가리킴.

```java
// 예제 5

class Car {
    private String modelName;
    private int modelYear;
    private String color;
    private int maxSpeed;
    private int currentSpeed;

    Car(String modelName, int modelYear, String color, int maxSpeed) {
        this.modelName = modelName;
        this.modelYear = modelYear;
        this.color = color;
        this.maxSpeed = maxSpeed;
        this.currentSpeed = 0;
    }
}
```

- 예제 5과 같이 생성자의 매개 변수 이름과 인스턴스 변수의 이름이 같을 경우 인스턴스 변수 앞에 this 키워드를 붙여 구분해야 한다.
  - this 참조 변수를 사용하여 인스턴스 변수에 접근 가능하다.
  - this 참조 변수를 사용할 수 있는 영역은 인스턴스 메소드뿐이다. 
    - 클래스 메소드에서는 사용 불가능하다.
  - 모든 인스턴스 메소드에는 this 참조 변수가 숨겨진 지역 변수로 존재하고 있다.

### this() 메소드

- 생성자 내부에서만 사용가능
- 같은 클래스의 다른 생성자 호출시 사용
- this() 메소드에 인수를 전달하면 생성자 중 메소드 시그니처가 일치하는 다른 생성자를 찾아 호출함.
  - `메소드 시그니처`(method signature) : 메소드의 이름과 메소드의 원형에 명시되는 매개변수 리스트

```java
// 예제 6 : this 참조 변수 & this() 메소드 사용

class Car {
    private String modelName;
    private int modelYear;
    private String color;
    private int maxSpeed;
    private int currentSpeed;

    Car(String modelName, int modelYear, String color, int maxSpeed) {
        // 매개변수를 가지는 생성자 Car 는 this 참조 변수를 사용하여 인스턴스 변수에 접근함!
        this.modelName = modelName;
        this.modelYear = modelYear;
        this.color = color;
        this.maxSpeed = maxSpeed;
        this.currentSpeed = 0;
    }

    Car() { 
        // 매개변수를 가지지 않는 생성자는 내부에서 this() 메소드를 통해 생성자를 호출! 
        // => 내부적으로 다른 생성자를 호출하여 인스턴스 변수 초기화 가능
        this("mycar", 2020, "흰색", 160); 
    }
    
    public String getModel() {
        return this.modelYear + "년식 " + this.modelName + " " + this.color;
    }
}

public class Method {
    public static void main(String[] args) {
        Car tcpCar = new Car();
        System.out.println(tcpCar.getModel()); // 2020년식 mycar 흰색
    }
}
```

- 한 생성자에서 다른 생성자를 호출 시, 반드시 해당 생성자의 첫 줄에서만 호출 가능하다.



## 메소드 오버로딩

### 메소드 시그니처 (method signature)

- 메소드의 선언부에 명시되내변수의 리스트를 가리킨다.
  - 만약 두 메소드가 매개변수의 개수, 타입, 순서까지 같다면 이 두 메소드그니처는 같다.

### 메소드 오버로딩 (method overloading)

- 같은 이름의 메소드를 중복하여 정의한다.

  - java에서는 원래 한 클래스 내에 같은 이름의 메소드를 둘 이상 가질 수 없지만 매개변수의 개수나 타입이 다르면 하나의 이름으로 메소드 작성이 가능하다.

    → 서로 다른 시그니처를 갖는 여러 메소드를 같은 이름으로 정의하는 것을 메소드 오버로딩이라 한다.

- 메소드 오버로딩을 통해 메소드에 사용되는 이름을 간소화되고 메소드 호출 시 전달해야 할 매개변수의 타입이나 개수에 크게 신경쓰지 않고 호출 가능하다.

- 객체 지향 프로그래밍의 특징 중 하나인 다형성(polymorphism)을 구현하는 방법 중 하나이다.

  ---

- 메소드 오버로딩 예

  - println() 메소드

    전달받는 매개변수의 타입에 따라 다양한 원형 중에서 적절한 원형을 호출한다.

#### 메소드 오버로딩의 조건

1. 메소드의 이름이 같아야 한다.
2. 메소드의 시그니처, 즉 매개변수의 개수 또는 타입이 달라야 한다.

메소드 오버로딩은 반환 타입과 관계가 없다.

※ 메소드의 시그니처는 같지만 반환 타입만이 다른 경우에는 오버로딩이 성립하지 않는다.

#### 메소드 오버로딩 예제

사용자가 오버로딩된 함수를 호출하면, 전달된 매개변수의 개수와 타입과 같은 시그니처를 가지는 메소드를 찾아 호출한다.

```java
// 예제 7 : 메소드의 원형 예제
// 함수의 오버로딩을 이용하여 정의한 display() 메소드 원형

// a. 전달받은 num1 그대로 출력
void display(int num1);
// b. 전달받은 두 정수의 곱 출력
void display(int num1, int num2);
// c. 전달받은 정수와 실수의 합을 출력
void display(int num1, double num2);
```

```java
// 예제 8 : 함수 호출 예제
// display() 메소드를 호출하면 컴파일러는 자동으로 같은 시그니처를 가지는 메소드를 찾아 호출

display(10); // 10 (a. display() 메소드 호출)
display(10, 20); // 200 (b. display() 메소드 호출)
display(10, 3.14); // 13.14 (c. display() 메소드 호출)
display(10, 'a'); // (b, c display() 메소드 모두 호출 가능)
```

`display(10, 'a');`에서 두번째 인수는 char 형 데이터로 int형 뿐 아니라 double 형으로도 타입 변환될 수 있기 때문에 자바 컴파일러가 어느 시그니처의 display() 메소드를 호출할지 불명확하다.

오버로딩한 메소드의 이러한 호출을 허용하지 않으며, 이 경우에는 더 작은 표현 범위를 갖는 int 형으로 자동 타입 변환된다.

```java
// 예제 9 : display() 메소드를 다양한 시그니처로 오버로딩하는 예제

class Test {
    static void display(int num1) { System.out.println(num1); }
    static void display(int num1, int num2) { System.out.println(num1 * num2); }
    static void display(int num1, double num2) { System.out.println(num1 + num2); }
}

public class Method {
    public static void main(String[] args) {
        Test myfunc = new Test();
        myfunc.display(10); // 10
        myfunc.display(10, 20); // 200
        myfunc.display(10, 3.14); // 13.14
        myfunc.display(10, 'a'); // 970
}
```

- 메소드 오버로딩은 매개변수의 타입뿐 아니라 매개변수의 개수를 달리해도 작성 가능하다.



## 재귀 호출

### 재귀 호출 (recursive call)

- 메소드 내부에서 해당 메소드가 다시 호출되는 것을 의미한다.
  - 자기 자신을 계속해서 호출하므로 메소드 내에 재귀 호출을 중단하도록 족건이 변경될 명령문을 반드시 포함해야 한다.



```java
// 예제 10 : 재귀 호출사용하지 않고 만든 sum() 메소드

int sum(int n) { // 1부터 n 까지의 합을 구하는 메소드
    int result = 0; 

    for (int i = 1; i <= n; i++) {
        result += i;
    }
    return result;
}
```

```java
// 예제 11 : 재귀 호출 이용

int recursiveSum(int n) {
    if (n == 1) {
        return 1;
    }
    return n + recursiveSum(int n-1)
}
```

- 예제 11번에서 if문이 존재하지 않는다면?

  실행 직후 스택 오버플로우 (stack overflow)에 의해 종료된다.

- if문 처럼 재귀 호출을 중단하기 위한 조건문을 반드시 포함해야 한다.
