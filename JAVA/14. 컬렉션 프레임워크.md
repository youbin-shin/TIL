# 14. 컬렉션 프레임워크

## 컬렉션 프레임워크란?

### 컬렉션 프레임워크 (collection framework)

- 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미한다.
- 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현한 것이다.
- 컬렉션 프레임 워크는 java의 인터페이스(interface)를 사용하여 구현된다.

### 컬렉션 프레임워크 주요 인터페이스

- 데이터를 저장하는 자료 구조에 따라 핵심이되는 주요 인터페이스를 정의한다.

  1. List 인터페이스
  2. Set 인터페이스
  3. Map 인터페이스

  List와 Set 인터페이스는 모두 Collection 인터페이스를 상속받지만, 구조상의 차이로 Map 인터페이스는 별도로 정의한다.

  List 인터페이스와 Set 인터페이스의 공통된 부분을 Collection 인터페이스에서 정의하고 있다.

#### 주요 인터페이스 특징

| 인터페이스 | 설명                                                         | 구현 클래스                                 |
| :--------: | ------------------------------------------------------------ | ------------------------------------------- |
|  List<E>   | 순서가 있는 데이터의 집합, 데이터의 중복 허용                | Vector, ArrayList, LinkedList, Stack, Queue |
|   Set<E>   | 순서가 없는 데이터의 집합, 데이터의 중복 허용 X              | HashSet, TreeSet                            |
| Map<K, V>  | 키와 값의 한 쌍으로 이루어지는 데이터의 집합, 순서 X<br />키는 중복을 허용하지 않지만, 값은 중복될 수 있음. | HashMap, TreeMap, Hashtable, Properties     |

### 컬렉션 클래스 (collection class)

- 컬렉션 프레임워크에 속하는 인터페이스를 구현한 클래스를 컬렉션 클래스 (collection class)라 한다.

- 컬렉션 프레임워크의 모든 컬렉션 클래스는 List와 Set, Map 인터페이스 중 하나의 인터페이스를 구현하고 있다.

  - 클래스 이름에도 구현한 인터페이스의 이름이 포함되어 바로 구분가능하다.

  ---

- Vector나 Hashtable과 같은 컬렉션 클래스는 이전부터 사용되어 기존 코드와의 호환을 위해 남아있지만 기존에 사용하던 컬렉션 클래스보다 새로 추가된 ArrayList나 HashMap 클래스를 사용하는 것이 성능 면에서도 더 좋은 결과를 얻을 수 있다.

```java
// 예제 1 : ArrayList 클래스를 이용하여 리스트 생성, 조작하기

import java.util.*;

public class Collection01 {
    public static void main(String[] args) {
        // 리스트 생성
        ArrayList<String> arrList = new ArrayList<String>();
 
        // 리스트에 요소의 저장
        arrList.add("1");
        arrList.add("2");
        arrList.add("3");
        arrList.add("4");
 
        // 리스트 요소의 출력
        for(int i = 0; i < arrList.size(); i++) {
            System.out.println(arrList.get(i));
        }
    }
}
// 출력 : 
// 1
// 2
// 3
// 4
```

#### Collection 인터페이스

- List와 Set 인터페이스의 많은 공통된 부분을 Collection 인터페이스에서 정의하고 두 인터페이스는 이를 상속받는다.
- Collection 인터페이스는 컬렉션을 다루는 가장 기본적인 동작을 정의하고 메소드로 제공한다.

|           메소드           | 설명                                                         |
| :------------------------: | ------------------------------------------------------------ |
|      boolean add(E e)      | 해당 컬렉션(collection)에 전달된 요소를 추가함. (선택적 기능) |
|        void clear()        | 해당 컬렉션의 모든 요소를 제거함. (선택적 기능)              |
| boolean contains(Object o) | 해당 컬렉션이 전달된 객체를 포함하고 있는지 확인함.          |
|  boolean equals(Object o)  | 해당 컬렉션과 전달된 객체가 같은지 확인함.                   |
|     boolean isEmpty()      | 해당 컬렉션이 비었는지 확인함.                               |
|   iterator<E> iterator()   | 해당 컬렉션의 반복자(iterator)를 반환함.                     |
|  boolean remove(Object o)  | 해당 컬렉션에서 전달된 객체를 제거함. (선택적 기능)          |
|         int size()         | 해당 컬렉션의 요소의 총 개수를 반환함.                       |
|     Object[]toArray()      | 해당 컬렉션의 모든 요소를 Object 타입의 배열로 반환함.       |



## List 컬렉션 클래스 

- List 인터페이스를 구현한 모든 List 컬렉션 클래스는 다음의 특징이 있다.
  1. 요소의 저장 순서가 유지된다.
  2. 같은 요소의 중복 저장을 허용한다.

- 대표적인 List 컬렉션 클래스에 속하는 클래스는 다음과 같다.
  1. `ArrayList<E>`
  2. `LinkedList<E>`
  3. `Vector<E>`
  4. `Stack<E>`

### `ArrayList<E>` 클래스

- 가장 많이 사용되는 컬렉션 클래스 중 하나이다.

- ArrayList 클래스는 내부적으로 배열을 이용하여 요소를 저장한다.

  - 배열을 이용하기 때문에 인덱스를 이용해 배열 요소에 빠르게 접근 가능하다.

  - 배열은 크기를 변경할 수 없는 인스턴스이므로 크기를 늘리기 위해서는 새로운 배열을 생성하고 기존의 요소들을 옮겨야하는 과정을 거친다.

    위의 과정은 자동으로 수행되지만 요소의 추가 및 삭제 작업에 걸리는 시간이 길다는 단점이 있다.

```java
// 예제 2 : 여러 ArrayList 메소드를 이용하여 리스트를 생성, 조작하기

ArrayList<Integer> arrList = new ArrayList<Integer>();

// add() 메소드를 이용한 요소의 저장
arrList.add(40);
arrList.add(20);
arrList.add(30);
arrList.add(10);

// for 문과 get() 메소드를 이용한 요소의 출력
for (int i = 0; i < arrList.size(); i++) {
    System.out.print(arrList.get(i) + " "); // 출력 : 40 20 30 10 
}

// remove() 메소드를 이용한 요소의 제거
arrList.remove(1);

// Enhanced for 문과 get() 메소드를 이용한 요소의 출력
for (int e : arrList) {
    System.out.print(e + " "); // 출력 : 40 30 10
}

// Collections.sort() 메소드를 이용한 요소의 정렬
Collections.sort(arrList);

// iterator() 메소드와 get() 메소드를 이용한 요소의 출력
Iterator<Integer> iter = arrList.iterator();
while (iter.hasNext()) {
    System.out.print(iter.next() + " "); // 출력 : 10 30 40 
}

// set() 메소드를 이용한 요소의 변경
arrList.set(0, 20);

for (int e : arrList) {
    System.out.print(e + " "); // 출력 : 20 30 40
}

// size() 메소드를 이용한 요소의 총 개수
System.out.println("리스트의 크기 : " + arrList.size()); // 출력 : 리스트의 크기 : 3
```

- 예제 2와 같이 컬렉션 클래스의 요소를 출력하는 방법은 for문, enhanced for 문, iterator() 메소드 등의 방법이 있다.

- java의 Collection은 인터페이스이며, Collections는 클래스임을 주의해야 한다.



### `LinkedList<E>` 클래스

- ArrayList 클래스가 배열을 이용하여 요소를 저장함으로써 발생하는 단점을 해결하기 위해 만들어졌다. LinkedList 클래스는 내부적으로 연결 리스트(linked list)를 이용하여 요소를 저장한다.
  - 배열은 저장된 요소가 순차적으로 저장된다.
  - 연결 리스트는 저장된 요소가 비순차적으로 분포되며 요소들 사이에 링크(link)로 연결하여 구성한다.
- 요소를 가리키는 참조만을 가지는 연결 리스트를 단일 연결 리스트(singly linked list)라 한다.
  - 단일 연결 리스트는 요소의 저장과 삭제 작업이 다음 요소를 가리키는 참조만 변경되어 빠르게 처리된다.
  - 현재 요소에서 이전 요소로 접근하기 매우 어렵다.
- 이전 요소를 가리키는 참조도 가지는 이중 연결 리스트(doubly linked list)가 더 사용된다.
  - LinkedList 클래스도 List 인터페이스를 구현하므로, ArrayList 클래스와 사용할 수 있는 메소드가 거의 같다.

```java
// 예제 3 : LinkedList 메소드를 이용하여 리스트를 생성, 조작하기

LinkedList<String> lnkList = new LinkedList<String>();

// add() 메소드를 이용한 요소의 저장
lnkList.add("넷");
lnkList.add("둘");
lnkList.add("셋");
lnkList.add("하나");

// for 문과 get() 메소드를 이용한 요소의 출력
for (int i = 0; i < lnkList.size(); i++) {
    System.out.print(lnkList.get(i) + " "); // 출력 : 넷 둘 셋 하나
}

// remove() 메소드를 이용한 요소의 제거
lnkList.remove(1);

// Enhanced for 문과 get() 메소드를 이용한 요소의 출력
for (String e : lnkList) {
    System.out.print(e + " "); // 출력 : 넷 셋 하나
}

// set() 메소드를 이용한 요소의 변경
lnkList.set(2, "둘");

for (String e : lnkList) {
    System.out.print(e + " "); // 출력 : 넷 셋 둘
}

// size() 메소드를 이용한 요소의 총 개수
System.out.println("리스트의 크기 : " + lnkList.size()); // 출력 : 리스트의 크기 : 3
```



### `Vector<E>` 클래스

- List 인터페이스를 상속받는다.
- Vector 클래스에서 사용할 수 있는 메소드는 ArrayList 클래스에서 사용할 수 있는 메소드와 같다.
  - 현재 기존 코드와의 호환성을 위해서만 남아있기에 Vector 클래스보다 ArrayList 클래스를 사용하는 것을 권장한다.



### List 인터페이스 메소드

- Collection 인터페이스를 상속받으므로 Collection 인터페이스에서 정의한 메소드도 모두 사용할 수 있다.

|           메소드           | 설명                                                         |
| :------------------------: | ------------------------------------------------------------ |
|      boolean add(E e)      | 해당 리스트(list)에 전달된 요소를 전달한다. (선택적 기능)    |
|  void add(int index, E e)  | 해당 리스트의 특정 위치에 전달된 요소를 추가한다. (선택적 기능) |
|        void clear()        | 해당 리스트의 모든 요소를 제거한다. (선택적 기능)            |
| boolean contains(Object o) | 해당 리스트가 전달된 객체를 포함하고 있는지 확인한다.        |
|  boolean equals(Object o)  | 해당 리스트와 전달된 객체가 같은지 확인한다.                 |
|      E get(int index)      | 해당 리스트의 특정 위치에 존재하는 요소를 반환한다.          |
|     boolean isEmpty()      | 해당 리스트의 비어있는지를 확인한다.                         |
|   iterator<E> iterator()   | 해당 리스트의 반복자(iterator)를 반환한다.                   |
|  boolean remove(Object o)  | 해당 리스트에서 전달된 객체를 제거한다. (선택적 기능)        |
| boolean remove(int index)  | 해당 리스트의 특정 위치에 존재하는 요소를 제거한다. (선택적 기능) |
|   E set(int index, E e)    | 해당 리스트의 특정 위치에 존재하는 요소를 전달받은 객체로 대체한다. |
|         int size()         | 해당 리스트의 요소의 총 개수를 반환한다.                     |
|     Object[] toArray()     | 해당 리스트의 모든 요소를 Object 타입의 배열을 반환한다.     |



## Stack과 Queue 

### `Stack<E>` 클래스

- List 컬렉션 클래스의 Vector 클래스를 상속받아 전형적인 스택 메모리 구조의 클래스를 제공한다.
  - 스택 메모리 구조 : 선형 메모리 공간에 데이터를 저장하면서 후입선출(LIFO)의 시멘틱 자료 구조 (나중에 저장된 데이터가 가장 먼저 인출되는 구조)

- Stack 클래스는 스택 메모리 구조를 표현하기 위해 Vector 클래스의 메소드 5개만 상속받아 사용한다.

  |        메소드        | 설명                                                         |
  | :------------------: | ------------------------------------------------------------ |
  |   boolean empty()    | 해당 스택이 비어있으면 true, 비어있지 않으면 false 반환한다. |
  |       E peek()       | 해당 스택 제일 상단에 있는 요소(마지막에 저장된 요소)를 반환한다. |
  |       E pop()        | 해당 스택의 제일 상단에 있는 요소(마지막에 저장된 요소)를 반환하고 해당 요소를 스택에서 제거한다. |
  |    E push(E item)    | 해당 스택의 제일 상단에 전달된 요소를 삽입한다.              |
  | int search(Object o) | 해당 스택에서 전달된 객체가 존재하는 위치의 인덱스를 반환한다. (인덱스는 제일 상단에 있는 요소의 위치부터 0이 아닌 1부터 시작한다.) |

```java
// 예제 4 : Deque 인터페이스를 구현한 ArrayDeque 클래스 사용
Deque<Integer> st = new ArrayDeque<Integer>();
```

```java
// 예제 5 : 여러 Stack 메소드를 사용하여 스택 메모리 구조 구현
Stack<Integer> st = new Stack<Integer>(); // 스택의 생성

// push() 메소드를 이용한 요소의 저장
st.push(4);
st.push(2);
st.push(3);
st.push(1);
 
// peek() 메소드를 이용한 요소의 반환
System.out.println(st.peek()); // 출력 : 1
System.out.println(st); // 출력 : [4, 2, 3, 1]
 
// pop() 메소드를 이용한 요소의 반환 및 제거
System.out.println(st.pop()); // 출력 : 1
System.out.println(st); // 출력 : [4, 2, 3]

// search() 메소드를 이용한 요소의 위치 검색
System.out.println(st.search(4)); // 출력 : 3
System.out.println(st.search(3)); // 출력 : 1
```

- ArrayDeque 클래스는 Stack 클래스와 달리 search() 메소드를 지원하지 않는다.



### `Queue<E>` 인터페이스

- 큐 메모리 구조는 별도의 인터페이스 형태로 제공된다.
  - 큐 메모리 구조 : 선형 메모리 공간에 데이터를 저장하면서 선입선출(FIFO)의 시멘틱 자료 구조 (가장 먼저 저장된 데이터가 가장 먼저 인출되는 구조)
- Queue 인터페이스를 상속받는 하위 인터페이스는 다음과 같다.
  1. Deque<E>
  2. BlockingDeque<E>
  3. BlockingQueue<E>
  4. TransferQueue<E>

- Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는 데 많이 사용된다.

- Queue 인터페이스는 큐 메모리 구조를 표현하기 위해 다음의 Collection 인터페이스 메소드만을 상속받아 사용한다.

  |       메소드       | 설명                                                         |
  | :----------------: | ------------------------------------------------------------ |
  |  boolean add(E e)  | 해당 큐의 맨 뒤에 전달된 요소를 삽입한다. 삽입에 성공하면 true를 반환하고 큐에 여유 공간이 없어 실패하면 IllegalStateException 발생한다. |
  |    E element()     | 해당 큐의 맨 앞에 있는 요소(제일 먼저 저장된 요소)를 반환한다. |
  | boolean offer(E e) | 해당 큐의 맨 뒤에 전달된 요소를 삽입한다.                    |
  |      E peek()      | 해당 큐의 맨 앞에 있는 요소를 반환한다. 만약 큐가 비어있으면 null을 반환한다. |
  |      E poll()      | 해당 큐의 맨 앞에 있는 요소를 반환하고 해당 요소를 큐에서 제거한다. 만약 큐가 비어있으면 null을 반환한다. |
  |     E remove()     | 해당 큐의 맨 앞에 있는 요소를 제거한다.                      |

- Deque 인터페이스를 구현한 ArrayDeque 클래스를 사용하면 빠른 큐를 구현할 수 있다.

  ```java
  // 예제 6
  Deque<Integer> qu = new ArrayDeque<Integer>();
  ```

```java
// 예제 7 : 여러 LinkedList 메소드를 이용하여 큐 메모리 구조 구현
LinkedList<String> qu = new LinkedList<String>(); // 큐의 생성
 
// add() 메소드를 이용한 요소의 저장
qu.add(4);
qu.add(2);
qu.add(3);
qu.add(1);
 
// peek() 메소드를 이용한 요소의 반환
System.out.println(qu.peek()); // 출력 : 4
System.out.println(qu); // 출력 : [4, 2, 3, 1]
 
// poll() 메소드를 이용한 요소의 반환 및 제거
System.out.println(qu.poll()); // 출력 : 4
System.out.println(qu); // 출력 : [2, 3, 1]
 
// remove() 메소드를 이용한 요소의 제거
qu.remove("1");
System.out.println(qu); // 출력 : [2, 3]
```



## Set 컬렉션 클래스 

## Map 컬렉션 클래스 

## Iterator 

## Comparable