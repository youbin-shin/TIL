# 15. 예외 처리

## 예외 처리 

### 오류(error)와 예외(exception)

- 자바 문법에 맞지 않는 코드를 작성하고 컴파일을 하면 자바 컴파일러는 문법 오류(syntax error)를 발생한다.
- 문법에 맞더라도 프로그램 실행시 예상치 못한 오류가 발생할 수 있다.

실행 중인 프로그램이 영향을 받는 것을 오류(error)와 예외(exception) 두가지로 구분할 수 있다.

- 오류 : 시스템 레벨에서 프로그램에서 심각한 문제를 야기하여 실행 중인 프로그램을 종료시킨다.
  - 개발자가 미리 예측하여 처리할 수 없는 것이 대부분이기에 오류에 대한 처리는 할 수 없다.
- 예외 : 실행 중 프로그램이 비상적으로 종류하지만 오류와 달리 발생할 수 있는 상황을 미리 예측하여 처리할 수 있다.
  - 예외 처리(exception handling)을 통해 예외 상황을 처리할 수 있도록 코드의 흐름을 바꿀 필요가 있다.

### 예외 처리(exception handling)

- 예외 처리를 위해 try / catch / finally 문을 사용할 수 있다.

```java
// 문법
try {
    예외를 처리하길 원하는 실행 코드;
} catch (e1) {
    e1 예외가 발생할 경우에 실행될 코드;
} catch (e2) {
    e2 예외가 발생할 경우에 실행될 코드;
}
...
finally {
    예외 발생 여부와 상관없이 무조건 실행될 코드;
}
```

1. try 블록: 맨 먼저 실행되는 코드로 발생한 예외는 catch 블록에서 처리된다.
2. catch 블록: try 블록에서 발생한 예외 코드나 예외 객체를 인수로 전달받아 그 처리를 담당한다.
3. finally 블록: tru 블록에서 예외가 발생했는지와 상관없이 맨 마지막에 무조건 실행된다.

- catch 블록과 finally 블록은 선택적인 옵션이다.

#### 적합한 try 구문

1. try / catch
2. try / finally
3. try / catch / ... / finally

다른 제어문과 달리 예외 처리문은 중괄호를 생략 가능하다.

### 예외 처리 메커니즘

다음과 같은 순서로 예외 처리가 진행된다.

1. try 블록에 도달한 프로그램의 제어는 try  블록 내의 코드를 실행한다.

   만약 예외가 발생(throw)하지 않고 finally 블록이 존재하면 프로그램의 제어는 바로 finally 블록으로 이동한다.

2. try 블록에서 예외가 발생하면 catch 핸들러는 다음과 같은 순서로 적절한 catch 블록을 찾는다.

   1. 스택에서 try 블록과 가장 가까운 catch 블록부터 검사한다.
   2. 적절한 catch 블록을 찾지 못하면 바로 다음 바깥쪽 try 블록 다음에 위치한 catch 블록을 차례로 검사한다.
   3. 가장 바깥쪽 try 블록까지 계속 검사한다.
   4. 그래도 적절한 catch 블록을 찾지 못하면 예외는 처리되지 못한다.

3. 만약 적절한 catch 블록을 찾게 되면 throw 문의 피연산자는 예외 객체의 형식 매개 변수로 전달된다.

4. 모든 예외 처리가 끝나면 프로그램의 제어는 finally 블록으로 이동한다.

5. finally 블록이 모두 처리되면 프로그램의 제어는 예외 처리문 바로 다음으로 이동한다.



## 예외 클래스 

### Exception 클래스

java에서 모든 예외의 조상 클래스가 되는 Exception 클래스는 다음과 같이 구분할 수 있다.

1. RuntimeException 클래스

   RuntimeException 클래스를 상속받는 자식 클래스들은 주로 치명적인 예외 상황을 발생시키지 않는 예외들로 구성된다.

   따라서 try / catch 문을 사용하기 보다 프로그램을 작성하면서 예외가 발생하지 않도록 하는 편이 좋다.

2. 그 외의 Exception 클래스의 자식 클래스

   그 외의 Exception 클래스의 자식 클래스들은 치명적인 예외 상황을 발생시키므로 반드시 try / catch 문을 사용하여 예외를 처리해야만 한다.

   따라서 그 이외의 Exception 클래스의 자식 클래스에 속하는 예외가 발생할 가능성이 있는 구문에는 반드시 예외 처리를 하도록 강제한다.

   만약 이러한 예외가 발생할 가능성이 있는 구문을 예외 처리하지 않았을 때 컴파일 시 오류를 발생한다.

### 예외 처리의 계층 관계

- 예외 발생시 try 블록과 가장 가까운 catch 블록부터 순서대로 검사한다. 따라서 여러 개의 catch 블록을 사용할 때는 Exception 클래스의 계층 관계에도 주의해야 한다.

```java
// 예제 1
byte[] list = {'a', 'b', 'c'};

try {
    System.out.write(list);
} catch (IOException e) {
    e.printStackTrace();
} catch (Exception e) {
    e.printStackTrace();
}
```

- 좁은 예외를 처리하는 catch 블록을 먼저 명시하고 범위가 더 넓은 예외를 처리하는 catch 블록은 나중에 명시해야 정상적으로 해당 예외를 처리할 수 있다.

### 여러 예외 타입 동시 처리

`|` 기호를 사용하여 하나의 catch 블록에서 여러 타입의 예외를 동시에 처리할 수 있다.

```java
// 예제 2-1 : | 사용 전
try {
    this.db.commit();
} catch (IOException e) {
    e.printStackTrace();
} catch (SQLException e) {
    e.printStackTrace();
}

// 예제 2-2 : | 사용 후
try {
    this.db.commit();
} catch (IOException | SQLException e) {
    e.printStackTrace();
}
```

- 둘 이상의 예외 타입을 동시에 처리하는 catch 블록에서 매개변수로 전달받은 예외 객체는 묵시적으로 final 제어자를 가지게 된다.

  => catch 블록 내에서 해당 매개변수에는 어떠한 값도 대입할 수 없다.



## 예외 발생 및 회피