# 13. 제네릭

## 제네릭의 개념

### 제네릭(generic) 이란?

- 데이터 타입(data type)을 일반화(generalize)함을 의미한다.
- 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법이다.
  - 컴파일 시 미리 타입 검사(type check)를 수행하면 다음의 장점을 가진다.
    1. 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높인다.
    2. 반환값에 대한 반환 타입 및 타입 검사에 들어가는 노력을 줄인다.
- 제네릭을 사용하면 컴파일 시 미리 타입이 정해지기에 타입 검사나 타입 변환과 같은 작업을 생략 가능하다.



### 제네릭의 선언 및 생성

```java
// 예제 1 : 클래스와 메소드에만 선언 가능

class MyArray<T> {
    T element;
    void setElement(T element) { this.element = element; }
    T getElement() { return element; }
}
```

- `T`를 타입 변수(type variable)라 하고 임의의 참조형 타입을 의미한다.

  - 어떠한 문자를 사용해도 상관없으며 여러 개의 타입 변수는 쉼표로 구분하여 명시가능하다.

- 타입 변수는 클래스에서뿐 아니라 메소드의 매개변수나 반환값으로도 사용 가능하다.

- 선언된 제네릭 클래스(generic class)를 생성할 때에는 타입 변수 자리에 사용할 실제 타입을 명시해야 한다.

  ```java
  // 예제 2
  MyArray<Integer> myArr = new MyArray<Integer>();
  ```

  - 예제 2는 MyArray 클래스에 사용된 타입 변수로 Integer 타입을 사용한다. 제네릭 클래스를 생성할 때 사용할 실제 타입을 명시하면 내부적으로 정의된 타입 변수가 명시된 실제 타입으로 변환되어 처리된다.
  - 타입 변수 자리에 사용할 실제 타입을 명시할 때 기본 타입을 바로 사용할 수 없다. 위의 예제와 같이 Integer와 같이 래퍼(wrapper) 클래스를 사용해야만 한다.

- Java SE 7부터 인스턴스 생성 시 타입을 추정할 수 있는 경우 타입 생략이 가능하다.

  ```java
  // 예제 3
  MyArray<Integer> myArr = new MyArray<>(); 
  ```

```java
// 예제 4 : 제네릭에서 적용되는 타입 변수의 다형성

import java.util.*;

class LandAnimal { public void crying() { System.out.println("육지동물"); } }
class Cat extends LandAnimal { public void crying() { System.out.println("야옹"); } }
class Dog extends LandAnimal { public void crying() { System.out.println("멍멍"); } }
class Sparrow { public void crying() { System.out.println("짹짹"); } }
class AnimalList<T> {
    ArrayList<T> al = new ArrayList<T>();
    void add(T animal) { al.add(animal); }
    T get(int index) { return al.get(index); }
    boolean remove(T animal) { return al.remove(animal); }
    int size() { return al.size(); }
}

public class Generic01 {
    public static void main(String[] args) {
        AnimalList<LandAnimal> landAnimal = new AnimalList<>(); // Java SE 7부터 생략가능함.

        landAnimal.add(new LandAnimal());
        landAnimal.add(new Cat());
        landAnimal.add(new Dog());
        // landAnimal.add(new Sparrow()); // 오류가 발생함.
 
        for (int i = 0; i < landAnimal.size() ; i++) {
            landAnimal.get(i).crying();
        }
    }
}
// 출력 
// 육지동물
// 야옹
// 멍멍
```

- 예제 4에서 Cat과 Dog 클래스는 LandAnimal 클래스를 상속받는 자식 클래스이므로 AnimalList<LandAnimal>에 추가 가능하다. 하지만 Sparrow 클래스는 타입이 달라 추가할 수 없다.

### 제네릭 제거 시기

- 선언되고 사용된 제네릭 타입은 컴파일 시 컴파일러에 의해 자동으로 검사되어 타입이 변환된다. 이후 코드 내의 모든 제네릭 타입은 제거되어 컴파일된 class 파일에는 제네릭 타입이 포함되지 않는다.

  - 제거 시기의 이유 ? 

    제네릭을 사용하지 않는 코드와의 호환성을 유지하기 위해서이다.



## 다양한 제네릭 표현

### 타입 변수의 제한

- 제네릭은 `T`와 같은 타입 변수(type variable)를 사용하여 타입을 제한한다.
  - extends 키워드를 사용하면 타입 변수에 특정 타입만을 사용하도록 제한 가능하다.

```java
// 예제 5
class AnimalList<T extends LandAnimal> {...}
```

- 예제 5와 같이 클래스의 타입 변수에 제한을 하면 클래스 내부에서 사용된 모든 타입 변수에 제한이 생긴다.

- 클래스가 아닌 인터페이스를 구현할 경우에도 implements 키워드가 아닌 `extends` 키워드를 사용해야만 한다.

  ```java
  // 예제 6
  interface WarmBlood {...}
  ...
  class AnmailList<T extends WarmBlood> {...} // implements 키워드를 사용해서는 안된다!
  ```

- 클래스와 인터페이스를 동시에 상속받고 구현해야 하면 엠퍼센트(&) 기호를 사용하면 된다.

  ```java
  // 예제 7
  class AnimalList<T extends LandAnimal & WarmBlood> { ... }
  ```

### 제네릭 메소드 (generic method)

- 메소드의 선언부에 타입 변수를 사용한 메소드를 말한다.
  - 타입 변수의 선언은 메소드 선언부에서 반환 타입 바로 앞에 위치한다.

```java
// 예제 8
public static <T> void sort( ... ) { ... }
```

※  제네릭 클래스에서 정의된 타입 변수 T와 제네릭 메소드에서 사용된 타입 변수 T는 전혀 별개이다.

### 와일드카드(wild card)의 사용

- 이름에 제한을 두지 않음을 표현하는 데 사용되는 기호를 의미한다.
- 자바의 제네릭에서는 물음표(?) 기호를 사용하여 와일드카드를 사용할 수 있다.

```java
// 문법
<?> // 타입 변수에 모든 타입을 사용할 수 있다.
<? extends T> // T 타입과 T 타입을 상속받는 자손 클래스 타입만을 사용 가능하다.
<? super T> // T 타입과 T 타입이 상속받은 조상 클래스 타입만을 사용 가능하다.
```
